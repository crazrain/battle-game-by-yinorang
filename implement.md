# 프로젝트 분석 보고서: 턴제 몬스터 격투 게임

이 문서는 `battle_game_by_yinorang` 프로젝트의 소스 코드를 분석하고, 구조, 핵심 로직, 데이터 흐름 등을 상세히 설명합니다.

---

## 1. 프로젝트 개요

이 프로젝트는 웹 브라우저에서 실행되는 **로컬 2인용 턴제 몬스터 격투 게임**입니다. 두 명의 플레이어가 각각 자신의 닉네임, 몬스터, 스킬을 설정한 후, 턴을 번갈아 가며 전투를 벌이는 방식입니다. 게임의 모든 진행 상황은 브라우저의 `localStorage`에 저장되어 언제든지 이어할 수 있습니다.

- **기술 스택**: HTML, CSS, JavaScript (ES Modules)
- **핵심 기능**:
    - 플레이어 및 몬스터 커스터마이징 (닉네임, 이미지, 스킬)
    - 턴제 전투 시스템
    - 경험치 획득 및 스킬 레벨업을 통한 성장 시스템
    - `localStorage`를 이용한 게임 상태 영속성

---

## 2. 디렉터리 및 파일 구조

프로젝트는 역할에 따라 명확하게 디렉터리로 분리되어 있습니다.

-   `css/style.css`: 게임의 전반적인 스타일과 UI 디자인을 담당합니다.
-   `assets/`: 이미지, 오디오 등 정적 리소스를 관리합니다.
-   `js/`: 게임의 모든 JavaScript 로직이 위치합니다.
    -   `main.js`: 게임의 시작점(Entry Point)이자 전체 흐름을 제어하는 메인 파일입니다.
    -   `js/core/`: 게임의 핵심 데이터 모델과 비즈니스 로직을 담당합니다.
    -   `js/ui/`: 사용자 인터페이스(UI) 생성 및 화면 전환을 담당합니다.
    -   `js/utils/`: 오디오 재생 등 보조 기능을 담당합니다.

---

## 3. 핵심 로직 분석 (`js/core/`)

`core` 디렉터리는 게임의 규칙과 데이터를 정의하는 클래스들로 구성됩니다.

-   **`GameState.js`**:
    -   게임의 모든 상태를 포함하는 중앙 관리 객체입니다.
    -   `players` 배열을 통해 두 명의 플레이어 정보를 모두 관리합니다.
    -   `saveState()`와 `loadState()` 정적 메서드를 통해 `localStorage`에 게임 상태를 JSON 형태로 저장하고 불러옵니다.

-   **`Player.js`**:
    -   플레이어의 데이터를 정의하는 클래스입니다.
    -   `nickname`, `monster` (Monster 객체), `exp`, `wins`, `loses` 등의 속성을 가집니다.
    -   `fromJSON()` 메서드를 통해 `localStorage`에서 불러온 JSON 데이터를 `Player` 인스턴스로 복원합니다.

-   **`Monster.js`**:
    -   몬스터의 데이터를 정의합니다.
    -   `imageBase64` (몬스터 이미지), `hp`, `maxHp`, `skills` (Skill 객체 배열) 등을 속성으로 가집니다.
    -   HP 업그레이드 로직(`upgradeHp`)을 포함합니다.

-   **`Skill.js`**:
    -   스킬의 데이터를 정의합니다.
    -   `name`, `minDamage`, `maxDamage`, `level` 속성을 가집니다.
    -   스킬 레벨업 시 필요 경험치 계산 및 공격력 강화 로직(`upgrade`)을 포함합니다.

-   **`BattleSystem.js`**:
    -   두 플레이어의 `Player` 객체를 받아 턴제 전투를 관리하는 핵심 시스템입니다.
    -   `startBattle()`: 선공 플레이어를 랜덤으로 결정하며 전투를 시작합니다.
    -   `attack()`: 공격을 수행하고, 데미지를 계산하여 상대방의 HP를 감소시킵니다.
    -   `switchTurn()`: 턴을 전환합니다.
    -   `checkWinCondition()`: 전투 종료(승/패) 조건을 확인합니다.

---

## 4. UI 및 화면 흐름 분석 (`js/ui/` 및 `main.js`)

UI는 동적으로 생성되며, `main.js`가 전체적인 화면 흐름을 제어합니다.

-   **`main.js`의 역할**:
    -   `initGame()`: 게임 시작 시 `localStorage`에서 상태를 불러오고, 오디오 파일을 미리 로드한 후 시작 화면(`showStartScreen`)을 표시합니다.
    -   `checkGameState()`: 게임의 상태를 순차적으로 확인하며 필요한 설정 화면으로 사용자를 안내하는 핵심 함수입니다. (플레이어1 닉네임 -> 몬스터 -> 스킬 -> 플레이어2 닉네임 -> ...)
    -   모든 설정이 완료되면 메인 메뉴(`showMainMenu`)를 표시합니다.
    -   `startBattleLogic()`: 전투 시작 로직을 담당하며, `BattleSystem`을 초기화하고 전투 화면(`showBattleScreen`)을 표시합니다.

-   **화면 모듈 (`js/ui/screens/`)**:
    -   각 파일(`startScreen.js`, `nicknameScreen.js` 등)은 특정 화면의 UI를 생성하고, 해당 화면의 이벤트 리스너를 등록하는 역할을 합니다.
    -   각 화면은 `show...` 함수와 `remove...Listener` 함수를 `export` 합니다.
    -   사용자 입력이 완료되면 `main.js`에서 전달받은 콜백 함수를 호출하여 다음 단계로 진행합니다. (예: 닉네임 입력 후 `onSave` 콜백 호출)

-   **`screenUtils.js`**:
    -   `createDOMElement`와 같은 유틸리티 함수를 제공하여 UI 요소 생성을 돕고 코드 중복을 줄입니다.

-   **`modal.js`**:
    -   게임 내에서 사용되는 확인/경고 모달 창을 생성하는 기능을 담당합니다.

---

## 5. 데이터 흐름 및 상태 관리

-   **중앙 상태 객체**: `main.js`에 선언된 `gameState` 변수가 게임의 모든 데이터를 담고 있는 유일한 소스(Single Source of Truth) 역할을 합니다.
-   **데이터 전달**: `gameState`는 각 화면을 표시하는 함수에 인자로 전달되어 UI에 데이터를 표시합니다.
-   **데이터 변경**: 사용자 입력(닉네임 저장, 스킬 업그레이드 등)이 발생하면, 해당 화면 모듈은 `gameState` 객체의 데이터를 직접 수정합니다.
-   **영속성**: 데이터에 변경이 생기면 `gameState.saveState()`가 호출되어 `localStorage`에 즉시 반영됩니다. 게임을 새로 시작하면 `GameState.loadState()`를 통해 이전 상태가 복원됩니다.

---

## 6. 결론 및 제안

-   **잘된 점**:
    -   `core`(데이터/로직)와 `ui`(화면)의 역할이 명확하게 분리되어 있습니다.
    -   ES6 클래스와 모듈 시스템을 사용하여 코드가 체계적으로 구성되어 있습니다.
    -   `localStorage`를 활용한 상태 저장/복원 기능이 안정적으로 구현되어 있습니다.

-   **개선 제안**:
    -   `main.js`의 `checkGameState` 함수가 여러 상태를 순차적으로 확인하는 `if-else` 구조로 되어 있어 다소 복잡합니다. 이를 상태 패턴(State Pattern)이나 더 작은 함수들로 분리하여 리팩토링하면 가독성과 유지보수성이 향상될 것입니다.
    -   현재는 데미지 피드백이 텍스트 로그로만 제공됩니다. `plan.md`에 언급된 대로 데미지 플로팅 애니메이션과 같은 시각적 효과를 추가하면 사용자 경험이 크게 향상될 것입니다.
    -   '외형 변경'과 같은 미구현 기획을 추가하여 콘텐츠를 확장할 수 있습니다.
